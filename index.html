<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>whc512 Site</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content>
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<link href=/index.xml rel=alternate type=application/rss+xml title="whc512 Site">
<link href=/index.xml rel=feed type=application/rss+xml title="whc512 Site">
<meta property="og:title" content="whc512 Site">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="http://example.org/">
<meta itemprop=name content="whc512 Site">
<meta itemprop=description content><meta name=twitter:card content="summary">
<meta name=twitter:title content="whc512 Site">
<meta name=twitter:description content>
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class="pb3-m pb6-l bg-black">
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
whc512 Site
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
<div class="tc-l pv3 ph3 ph4-ns">
<h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
whc512 Site
</h1>
</div>
</div>
</header>
<main class=pb7 role=main>
<article class="cf ph3 ph5-l pv3 pv4-l f4 tc-l center measure-wide lh-copy mid-gray">
</article>
<div class="pa3 pa4-ns w-100 w-70-ns center">
<h1 class=flex-none>
Recent Posts
</h1>
<section class="w-100 mw8">
<div class="relative w-100 mb4">
<article class="bb b--black-10">
<div class="db pv4 ph3 ph0-l no-underline dark-gray">
<div class="flex flex-column flex-row-ns">
<div class="blah w-100">
<h1 class="f3 fw1 athelas mt0 lh-title">
<a href=/posts/global_rate_limit/ class="color-inherit dim link">
Global rate limit
</a>
</h1>
<div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
rate limit 对于线上服务的稳定性相当重要。单机版的 rate limit 有很多的算法，不具体展开。微服务一般需要分布式的 rate limit. 设计全局 rate limit 有3个思路。
平均分摊到单机 将 limit 平均分配到单机，默认每一个实例会承担相同的流量。这种方法需要事先确定实例数量，并且可能会有较大的误差。
sticky session 通过 load balance 策略，比如一致性哈希，总是将相同场景的请求转发到同一个(或一批)实例上。这种方法巧妙地将全局问题转化为单机问题。优点是实现简单，缺点也很致命，它的容错和伸缩性都比较差。一般不会用于关键的场景。
中心存储 通过 redis/cassadra 将计数信息中心化存储。这种方式可能会在请求量大的时候会有性能问题。
</div>
<a href=/posts/global_rate_limit/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
</div>
</div>
</div>
</article>
</div>
<div class="relative w-100 mb4">
<article class="bb b--black-10">
<div class="db pv4 ph3 ph0-l no-underline dark-gray">
<div class="flex flex-column flex-row-ns">
<div class="blah w-100">
<h1 class="f3 fw1 athelas mt0 lh-title">
<a href=/posts/lru/ class="color-inherit dim link">
Lru 的改进
</a>
</h1>
<div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
lru 是常用的缓存置换算法，充分地利用了本地性，它假设最长时间没有被使用的数据将来被使用的可能性更低。 但是在实际的系统中，有不少场景并没有很强的本地性，比如数据库连续扫描大片的数据，或者循环读取比缓存容量大的数据。在这些场景下，缓存命中率会变得很低，而且会有大量的数据置换操作，导致性能变差。
lru/k 和 2Q 解决这个问题的思路是将数据区分为热数据和冷数据，在短期内多次读取的数据才是热数据，会保存更长的时间，短期内只读取过一次的数据是冷数据，会被很快置换。热数据和冷数据的置换策略也有不同，热数据用 LRU，冷数据用 FIFO。这种思路很好地适用于连续扫描大片数据的场景。 mysql 使用了类似的思路。它将整个缓存分成占 5/8 的热数据区和 3/8 的冷数据区。当缓存满了之后，首先插入到 3/8 的位置，冷数据去的数据只有在 1s 内被再次使用才会被移入到热数据区。同时对热数据区的数据移动也做了优化，只有热数据区后3/4 的数据被访问到的时候才会移动，这样可以避免热数据频繁移动。
</div>
<a href=/posts/lru/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
</div>
</div>
</div>
</article>
</div>
<div class="relative w-100 mb4">
<article class="bb b--black-10">
<div class="db pv4 ph3 ph0-l no-underline dark-gray">
<div class="flex flex-column flex-row-ns">
<div class="blah w-100">
<h1 class="f3 fw1 athelas mt0 lh-title">
<a href=/posts/bitcask/ class="color-inherit dim link">
Bitcask intro
</a>
</h1>
<div class="f6 f5-l lh-copy nested-copy-line-height nested-links">
Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好 Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。
</div>
<a href=/posts/bitcask/ class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1">read more</a>
</div>
</div>
</div>
</article>
</div>
</section>
<section class=w-100>
<h1 class=f3>More</h1>
<h2 class="f5 fw4 mb4 dib mr3">
<a href=/posts/go_plugin/ class="link black dim">
Go plugin
</a>
</h2>
<h2 class="f5 fw4 mb4 dib mr3">
<a href=/posts/service_mesh/ class="link black dim">
Service mesh introduction
</a>
</h2>
<h2 class="f5 fw4 mb4 dib mr3">
<a href=/posts/qinzhi/ class="link black dim">
秦制两千年
</a>
</h2>
<a href=/posts/ class="link db f6 pa2 br3 bg-mid-gray white dim w4 tc">All Posts</a>
</section>
</div>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://example.org/>
&copy; whc512 Site 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>