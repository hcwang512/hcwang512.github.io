<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>whc512 Site</title><link>http://example.org/</link><description>Recent content on whc512 Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 26 Oct 2021 00:14:04 +0800</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>Lru 的改进</title><link>http://example.org/posts/lru/</link><pubDate>Tue, 26 Oct 2021 00:14:04 +0800</pubDate><guid>http://example.org/posts/lru/</guid><description>lru 是常用的缓存置换算法，充分地利用了本地性，它假设最长时间没有被使用的数据将来被使用的可能性更低。 但是在实际的系统中，有不少场景并没有很强的本地性，比如数据库连续扫描大片的数据，或者循环读取比缓存容量大的数据。在这些场景下，缓存命中率会变得很低，而且会有大量的数据置换操作，导致性能变差。
lru/k 和 2Q 解决这个问题的思路是将数据区分为热数据和冷数据，在短期内多次读取的数据才是热数据，会保存更长的时间，短期内只读取过一次的数据是冷数据，会被很快置换。热数据和冷数据的置换策略也有不同，热数据用 LRU，冷数据用 FIFO。这种思路很好地适用于连续扫描大片数据的场景。 mysql 使用了类似的思路。它将整个缓存分成占 5/8 的热数据区和 3/8 的冷数据区。当缓存满了之后，首先插入到 3/8 的位置，冷数据去的数据只有在 1s 内被再次使用才会被移入到热数据区。同时对热数据区的数据移动也做了优化，只有热数据区后3/4 的数据被访问到的时候才会移动，这样可以避免热数据频繁移动。</description></item><item><title>Bitcask intro</title><link>http://example.org/posts/bitcask/</link><pubDate>Fri, 10 Sep 2021 17:12:04 +0800</pubDate><guid>http://example.org/posts/bitcask/</guid><description>Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好 Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。</description></item><item><title>Go plugin</title><link>http://example.org/posts/go_plugin/</link><pubDate>Thu, 02 Sep 2021 23:34:52 +0800</pubDate><guid>http://example.org/posts/go_plugin/</guid><description>golang 是静态编译型语言，在编译时就需要将所有引用的包加载到最终的可执行程序中。go plugin 提供了在运行时动态加载外部功能的能力。go plugin 带来的好处是可以动态加载，可插拔，可独立开发。其典型的使用场景是
业务逻辑由多个代码模块组成，这些模块由不同的团队维护。可以独立开发，发布. 业务的总体流程是相对固定的，针对不同的业务执行不同的插件。 使用的时候先将 plugin 编译为 so 动态库，在主函数中打开 so 文件，即可查找到 plugin 中的可导出变量和方法。
go plugin 的一个非常严重的缺点在于需要保证 plugin 和主工程的 go 版本，平台，编译参数都一致，否则会有 panic 报错。这个缺陷极大地限制了 go plugin 的使用。
hashicorp go-plugin 因此 hashicorp 开发了 go-plugin 项目，plugin 是一个独立进程，与主进程通过本地网络 grpc 调用来双向交换数据。因为是进程间通信，而且传输数据是通过 pb 编码的。因此比 go plugin 有很多的好处。
不依赖 go 版本，平台，编译参数。 因为运行 plugin 在一个独立的进程中，因此 plugin panic 不会影响到主进程 支持双向通信 支持更多的语言 协议支持版本号。可以确保主进程总是适配 plugin 版本 支持多语言实现 plugin 可以做到平滑热更新 go-plugin 因为涉及到网络通信，数据编解码，因此在性能上带来一定的损耗。一些优化思路包括
网络协议优化，支持多路复用 合并小请求 支持内置 rpc server，减少 cgo 的调用。grpc 为远程调用做了很多二外的封装和处理逻辑。这些对本地网络通信是不需要的。 异步发送和接收 优化数据编码协议，降低协议解析开销。比如使用 gogoPB 零拷贝及重复利用 buffer 等 做了这些优化之后，基本可以做到和 native 代码相当的性能，包括吞吐量和时延。</description></item><item><title>Service mesh introduction</title><link>http://example.org/posts/service_mesh/</link><pubDate>Thu, 02 Sep 2021 11:55:49 +0800</pubDate><guid>http://example.org/posts/service_mesh/</guid><description>为什么需要 service_mesh 微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。
超时 重试 熔断 限速节流 动态服务发现 动态路由 分布式追踪以及运行时指标 安全通信和访问控制 这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh. mesh 的结构 上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。
总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。 总结 service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。</description></item><item><title>秦制两千年</title><link>http://example.org/posts/qinzhi/</link><pubDate>Thu, 02 Sep 2021 00:19:38 +0800</pubDate><guid>http://example.org/posts/qinzhi/</guid><description>周末翻了 《秦制两千年》这本书，受到很深的震撼。
书中主要的观点是中国历史上从秦朝到清朝，虽然政治制度不断演化，本质上是秦制。而秦制的主要特点是追求散沙化和原子化的扁平社会结构，尽可能管控、汲取人力和物力，最终达到利出一孔，国富民穷的结果。
秦制并不追求人的全面而自由的发展，相反，它通过制度想要塑造的是愚民，贫民，弱民。这些制度有些是把农民完全禁锢在土地上，禁止流动；有些是通过繁重的赋税使得民众无法积累财产，甚至害怕拥有财产；有些是通过盐铁官营等措施，加重民众的经济负担；有些是通过连坐和告密制度营造恐怖，使得人人自危。等等不一而足。
与之形成对比的是，英国在13世纪就通过大宪章来限制国王的权力，保护民众的财产权和人身自由。
很多这种政策即使今天依然能找到影子，我们能顺利走出秦制吗？</description></item></channel></rss>