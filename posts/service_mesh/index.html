<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Service mesh introduction | whc512 Site</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="为什么需要 service_mesh 微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。
 超时 重试 熔断 限速节流 动态服务发现 动态路由 分布式追踪以及运行时指标 安全通信和访问控制 这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh.  mesh 的结构 上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。
总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。 总结 service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。">
<meta name=generator content="Hugo 0.88.0">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Service mesh introduction">
<meta property="og:description" content="为什么需要 service_mesh 微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。
 超时 重试 熔断 限速节流 动态服务发现 动态路由 分布式追踪以及运行时指标 安全通信和访问控制 这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh.  mesh 的结构 上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。
总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。 总结 service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/service_mesh/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-02T11:55:49+08:00">
<meta property="article:modified_time" content="2021-09-02T11:55:49+08:00">
<meta itemprop=name content="Service mesh introduction">
<meta itemprop=description content="为什么需要 service_mesh 微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。
 超时 重试 熔断 限速节流 动态服务发现 动态路由 分布式追踪以及运行时指标 安全通信和访问控制 这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh.  mesh 的结构 上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。
总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。 总结 service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。"><meta itemprop=datePublished content="2021-09-02T11:55:49+08:00">
<meta itemprop=dateModified content="2021-09-02T11:55:49+08:00">
<meta itemprop=wordCount content="53">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Service mesh introduction">
<meta name=twitter:description content="为什么需要 service_mesh 微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。
 超时 重试 熔断 限速节流 动态服务发现 动态路由 分布式追踪以及运行时指标 安全通信和访问控制 这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh.  mesh 的结构 上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。
总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。 总结 service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
whc512 Site
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class=mt3>
<a href="https://www.facebook.com/sharer.php?u=http://example.org/posts/service_mesh/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a>
<a href="https://twitter.com/share?url=http://example.org/posts/service_mesh/&text=Service%20mesh%20introduction" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.org/posts/service_mesh/&title=Service%20mesh%20introduction" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
</div>
<h1 class="f1 athelas mt3 mb1">Service mesh introduction</h1>
<time class="f6 mv4 dib tracked" datetime=2021-09-02T11:55:49+08:00>September 2, 2021</time>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h2 id=为什么需要-service_mesh>为什么需要 service_mesh</h2>
<p>微服务的兴起和发展改变了工程师开发，构建，部署程序的方式。我们从单体应用的庞大代码库、扩展困难、迭代缓慢、单一技术栈的泥坑中被解救出来，旋即陷入了分布式系统的各种问题中。网络是不可靠的，网络的延迟是不稳定的，带宽是有限的，网络传输是有代价的，网络是不安全的，网络是异质的。诸多原因导致构建高可用，弹性的分布式系统是异常艰难的。经过多年的积累，我们总结出了一套通用技术指南。</p>
<ul>
<li>超时</li>
<li>重试</li>
<li>熔断</li>
<li>限速节流</li>
<li>动态服务发现</li>
<li>动态路由</li>
<li>分布式追踪以及运行时指标</li>
<li>安全通信和访问控制
这些功能在实现的时候应该作为公用库，与业务逻辑解耦。Twitter 的 rpc 框架 finagle, Facebook 的 http 框架 proxygen 就是很好的例子。而这依然有一些问题。需要专门的团队来维护这些通用库；对不同的框架，运行时，语言都需要实现这些功能；对业务开发依然有较高的心智成本；治理成本比较高，升级维护困难。解决这些问题的思路就在于将公用库设计为位于网络栈和应用业务逻辑的独立层，即透明网络代理，作为独立的运行单元，与业务不再直接，紧密关联。即 service mesh.</li>
</ul>
<h2 id=mesh-的结构>mesh 的结构</h2>
<p><img src=/images/mesh_arch.png alt="mesh 结构">
上图清晰地描述了 service mesh 在微服务中的位置和功能。我们会以 linkerd 为例分析 mesh 的结构。</p>
<p>总体来说，linkerd 主要由控制面和数据面构成。其中控制面为数据面上的行为提供控制数据；数据面则是由 rust 编写的轻量级代理，以 sidecar 的形式与应用容器一起部署，拦截处理所有的网络流量。
<img src=/images/linkerd_arch.png alt="linkerd 结构"></p>
<h2 id=总结>总结</h2>
<p>service mesh 是微服务架构趋于成熟的标志。kubernetes 战胜 mesos, swarm 赢得了编排调度系统的竞争，kubernetes 的网络模型的竞争也基本结束。或许在不远的将来，service mesh 会成为 kubernetes 上的标配，并且有一个统一的实现。</p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://example.org/>
&copy; whc512 Site 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>