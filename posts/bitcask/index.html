<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Bitcask intro | whc512 Site</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
 高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好  Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。">
<meta name=generator content="Hugo 0.88.1">
<meta name=ROBOTS content="NOINDEX, NOFOLLOW">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Bitcask intro">
<meta property="og:description" content="Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
 高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好  Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。">
<meta property="og:type" content="article">
<meta property="og:url" content="http://example.org/posts/bitcask/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-10T17:12:04+08:00">
<meta property="article:modified_time" content="2021-09-10T17:12:04+08:00">
<meta itemprop=name content="Bitcask intro">
<meta itemprop=description content="Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
 高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好  Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。"><meta itemprop=datePublished content="2021-09-10T17:12:04+08:00">
<meta itemprop=dateModified content="2021-09-10T17:12:04+08:00">
<meta itemprop=wordCount content="42">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Bitcask intro">
<meta name=twitter:description content="Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括
 高性能的随机读写单个数据 支持高吞吐地写入数据 能够处理比内存大的数据，并且性能不随着数据量增长而变差 好的容灾处理，包括快速恢复和防止丢数据 备份和恢复容易 代码和数据结构简单 高负载下的性能依旧足够好  Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 PUT 操作就只需要追加写入到文件中，性能会很好；对于 GET 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。 因为 PUT, DEL, UPDATE 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。
Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
whc512 Site
</a>
<div class="flex-l items-center">
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class=mt3>
<a href="https://www.facebook.com/sharer.php?u=http://example.org/posts/bitcask/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg>
</a>
<a href="https://twitter.com/share?url=http://example.org/posts/bitcask/&text=Bitcask%20intro" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
<a href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.org/posts/bitcask/&title=Bitcask%20intro" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg>
</a>
</div>
<h1 class="f1 athelas mt3 mb1">Bitcask intro</h1>
<time class="f6 mv4 dib tracked" datetime=2021-09-10T17:12:04+08:00>September 10, 2021</time>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>Bitcask 是一个高效的基于哈希表结构的 kv 数据库。它要实现的目标包括</p>
<ul>
<li>高性能的随机读写单个数据</li>
<li>支持高吞吐地写入数据</li>
<li>能够处理比内存大的数据，并且性能不随着数据量增长而变差</li>
<li>好的容灾处理，包括快速恢复和防止丢数据</li>
<li>备份和恢复容易</li>
<li>代码和数据结构简单</li>
<li>高负载下的性能依旧足够好</li>
</ul>
<p>Bitcask 的设计非常简单，数据通过追加的方式写到文件中，同时在内存中保存 key 对应的位置。这样对于 <code>PUT</code> 操作就只需要追加写入到文件中，性能会很好；对于 <code>GET</code> 操作需要从内存中找到 offset，再从文件指定位置读取，需要一次磁盘寻址的时间，而且可以通过使用文件系统的 read ahead cache 来加速读取。
因为 <code>PUT</code>, <code>DEL</code>, <code>UPDATE</code> 都是追加写，随着时间的推移，数据量不断膨胀，肯定需要 merge 操作把老数据清除掉。merge 的时候只对已经不更新的文件进行操作，生成新的只包含最新数据的文件。为了加快启动的速度，每一个数据文件都会有一个 hint 文件，里面包含了 key 和对应的元信息，这样 hint 文件会很小。</p>
<p>Bitcask 完美地实现了上面的这些要求。但是 Bitcask 会占用大量的内存，尤其是对于存储小数据的场景来说，内存/磁盘比会比较大。当然这个问题也可以很简单地通过水平分片来解决。</p>
<p><img src=/images/bitcask_dir.png alt="bitcash 文件"></p>
<p><img src=/images/bitcask_data.png alt="bitcash 数据结构"></p>
<p><img src=/images/bitcask_get.png alt="bitcash get操作"></p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://example.org/>
&copy; whc512 Site 2021
</a>
<div>
</div>
</div>
</footer>
</body>
</html>